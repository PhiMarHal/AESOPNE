<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertical Launcher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #2c3e50;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
            margin: 0 auto;
            max-width: 56.25vh;
            max-height: 100vh;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        class VerticalLauncher extends Phaser.Scene {
            constructor() {
                super({ key: 'VerticalLauncher' });

                // Game configuration
                this.GRAVITY = 1500;
                this.CANNON_POWER = 3000;
                this.SEA_LEVEL = 1400;
                this.SHIP_SIZE = 384;
                this.CANNON_SIZE = 96;
                this.CANNONBALL_SIZE = 48;
                this.FLYING_BALL_SIZE = 80;
                this.PIXELS_PER_METER = 20;
                this.CANNON_CHARGE_TIME = 500;
                this.CANNON_COOLDOWN_TIME = 1000;
                this.RESPAWN_DISTANCE = 1200;

                // Game state
                this.gameState = 'menu';
                this.cannonballSlots = [true, true, true, true]; // Track which slots have cannonballs
                this.maxHeight = 0;
                this.currentHeight = 0;
                this.personalBest = 0;
                this.flyingBallSpawnRate = 2000;
                this.flyingBallTimer = 0;
                this.lastPointerPosition = { x: 450, y: 800 };
                this.cannonAngle = 0;
                this.cameraFollowing = false;
                this.gameStartTime = null;
                this.gameOverTimer = null;
                this.initialSpawnCounter = 0;
                this.highestAltitudeZone = 0;
                this.cannonCharging = false;
                this.cannonChargeStart = 0;
                this.dormantCannonballs = [];

                // Cooldown system
                this.cannonOnCooldown = false;
                this.cannonCooldownStart = 0;
                this.cooldownGraphics = [];
                this.isRollingCannonballs = false;

                // Cloud system
                this.clouds = [];
                this.cloudGridData = new Map(); // Stores pre-generated cloud positions by grid key
                this.lastCloudCheck = 0;
                this.cloudCheckInterval = 300; // Check every 300ms

                console.log('Vertical Launcher initialized with slot-based cannonball system');
            }

            preload() {
                // Load sprite assets
                this.load.image('cannonball', 'assets/cannonball.png');
                this.load.image('wing', 'assets/wing.png');
                this.load.image('ship', 'assets/ship.png');
                this.load.image('cannon', 'assets/cannon.png');
                this.load.image('cloud_1', 'assets/cloud_1.png');
                this.load.image('cloud_2', 'assets/cloud_2.png');
                this.load.image('button_help', 'assets/button_help.png');
                this.load.image('button_destruct', 'assets/button_destruct.png');
            }

            create() {
                console.log('Creating game...');

                // Load personal best
                this.personalBest = parseInt(localStorage.getItem('verticalLauncherBest') || '0');

                // Initialize all groups and variables first
                this.flyingBalls = this.physics.add.group();
                this.cannonballProjectiles = this.physics.add.group();
                this.gameElements = [];
                this.titleElements = [];

                // Create infinite background
                this.gameBackground = this.add.rectangle(0, this.SEA_LEVEL - 250000, 200000, 500000, 0x87CEEB);
                this.seaFloor = this.add.rectangle(0, this.SEA_LEVEL + 800, 200000, 1600, 0x2c5f7b);
                this.sea = this.add.rectangle(0, this.SEA_LEVEL, 50000, 400, 0x3498db);

                // Create UI areas - fixed to camera
                this.topUI = this.add.rectangle(450, 100, 900, 200, 0x34495e);
                this.topUI.setScrollFactor(0);
                this.topUI.setDepth(999);

                this.bottomUI = this.add.rectangle(450, 1500, 900, 200, 0x34495e);
                this.bottomUI.setScrollFactor(0);
                this.bottomUI.setDepth(999);

                // Create ship
                this.ship = this.physics.add.sprite(450, this.SEA_LEVEL - this.SHIP_SIZE / 2, 'ship');
                this.ship.setDisplaySize(this.SHIP_SIZE, this.SHIP_SIZE);
                this.ship.body.setSize(this.SHIP_SIZE, this.SHIP_SIZE);
                this.ship.body.setGravityY(0);
                this.ship.body.setCollideWorldBounds(false);
                this.ship.body.setDrag(0.98);
                this.ship.body.setAllowGravity(false);

                // Create cannon
                this.cannon = this.add.image(this.ship.x, this.ship.y + 80, 'cannon');
                this.cannon.setDisplaySize(this.CANNON_SIZE, this.CANNON_SIZE * 2);
                this.cannon.setOrigin(0.5, 0.5);

                // Create UI text - fixed to camera
                this.heightText = this.add.text(40, 60, 'Height: 0m', {
                    fontSize: '40px',
                    fill: '#ffffff'
                });
                this.heightText.setScrollFactor(0);
                this.heightText.setDepth(1000);

                this.personalBestText = this.add.text(40, 110, `Best: ${this.personalBest}m`, {
                    fontSize: '32px',
                    fill: '#ecf0f1'
                });
                this.personalBestText.setScrollFactor(0);
                this.personalBestText.setDepth(1000);

                // Create cannonball UI with new positioning - rightmost slot centered at 450
                this.cannonballUI = [];
                this.cannonballPlaceholders = []; // Gray placeholders always visible
                this.cooldownGraphics = [];
                this.cannonballSlotPositions = [90, 210, 330, 450]; // Rightmost slot at center

                for (let i = 0; i < 4; i++) {
                    // Create gray placeholder (always visible)
                    const placeholder = this.add.image(this.cannonballSlotPositions[i], 1500, 'cannonball');
                    placeholder.setDisplaySize(this.CANNONBALL_SIZE * 1.9, this.CANNONBALL_SIZE * 1.9);
                    placeholder.setScrollFactor(0);
                    placeholder.setDepth(999); // Behind actual cannonballs
                    placeholder.setTint(0x7f8c8d);
                    placeholder.setAlpha(0.5);
                    this.cannonballPlaceholders.push(placeholder);

                    // Create actual cannonball (shows when slot is filled)
                    const ball = this.add.image(this.cannonballSlotPositions[i], 1500, 'cannonball');
                    ball.setDisplaySize(this.CANNONBALL_SIZE * 1.9, this.CANNONBALL_SIZE * 1.9);
                    ball.setScrollFactor(0);
                    ball.setDepth(1000); // On top of placeholders
                    this.cannonballUI.push(ball);

                    // Create cooldown circle graphics
                    const cooldownGraphic = this.add.graphics();
                    cooldownGraphic.setScrollFactor(0);
                    cooldownGraphic.setDepth(1001);
                    this.cooldownGraphics.push(cooldownGraphic);
                }

                // Create help button - symmetric with leftmost cannonball
                this.helpButton = this.add.image(810, 1500, 'button_help'); // 810 = 450 + (450-90)
                this.helpButton.setDisplaySize(this.CANNONBALL_SIZE * 1.9, this.CANNONBALL_SIZE * 1.9);
                this.helpButton.setScrollFactor(0);
                this.helpButton.setDepth(1000);
                this.helpButton.setInteractive();
                this.helpButton.on('pointerdown', () => this.showHelpPopup());

                // Initialize cloud system
                this.initializeCloudSystem();

                // Store elements
                this.gameElements = [
                    this.gameBackground, this.seaFloor, this.sea, this.ship, this.cannon
                ];

                this.uiElements = [
                    this.topUI, this.bottomUI, this.heightText,
                    this.personalBestText, ...this.cannonballPlaceholders, ...this.cannonballUI, ...this.cooldownGraphics,
                    this.helpButton
                ];

                // Create title screen
                this.titleBG = this.add.rectangle(450, 800, 900, 1600, 0x2c3e50);
                this.titleBG.setScrollFactor(0);
                this.titleBG.setDepth(2000);

                this.titleText = this.add.text(450, 500, 'VERTICAL\nLAUNCHER', {
                    fontSize: '72px',
                    fill: '#ffffff',
                    fontWeight: 'bold',
                    align: 'center'
                }).setOrigin(0.5);
                this.titleText.setScrollFactor(0);
                this.titleText.setDepth(2001);

                this.playButton = this.add.rectangle(450, 800, 360, 120, 0x27ae60);
                this.playButton.setScrollFactor(0);
                this.playButton.setDepth(2001);

                this.playButtonText = this.add.text(450, 800, 'PLAY GAME', {
                    fontSize: '40px',
                    fill: '#ffffff',
                    fontWeight: 'bold'
                }).setOrigin(0.5);
                this.playButtonText.setScrollFactor(0);
                this.playButtonText.setDepth(2002);

                this.titleElements = [this.titleBG, this.titleText, this.playButton, this.playButtonText];

                // Start with title screen
                this.showTitleScreen();

                // Set up interactions
                this.playButton.setInteractive();
                this.playButton.on('pointerdown', () => {
                    console.log('Play button clicked');
                    this.startGame();
                });

                // Input handling
                this.input.on('pointermove', (pointer) => {
                    this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                    if (this.gameState === 'playing') {
                        this.updateCannonAngle();
                    }
                });

                this.input.on('pointerdown', (pointer) => {
                    const canClick = this.gameState === 'playing' &&
                        this.gameStartTime &&
                        (this.time.now - this.gameStartTime > 500) &&
                        !this.cannonCharging &&
                        !this.cannonOnCooldown &&
                        !this.isRollingCannonballs &&
                        this.hasCannonballInRightmostSlot();

                    if (canClick) {
                        this.lastPointerPosition = { x: pointer.x, y: pointer.y };
                        this.updateCannonAngle();
                        this.startCannonCharge();
                    }
                });

                this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

                // Physics
                this.physics.world.setBounds(-100000, this.SEA_LEVEL - 300000, 200000, 300000);
                this.physics.add.overlap(this.ship, this.flyingBalls, this.collectFlyingBall, null, this);

                console.log('Game created successfully');
            }

            initializeCloudSystem() {
                // Pre-generate cloud data using a 2D grid system
                // This ensures clouds everywhere the player might go
                console.log('Initializing 2D grid-based cloud system...');

                // Create a pool of cloud sprites that we'll reuse
                this.clouds = [];
                for (let i = 0; i < 30; i++) { // Larger pool to prevent exhaustion
                    const cloudType = i % 2 === 0 ? 'cloud_1' : 'cloud_2';
                    const cloud = this.add.image(0, 0, cloudType);
                    cloud.setVisible(false);
                    cloud.setDepth(10); // Behind game elements but above background
                    cloud.setAlpha(0.8); // Slightly transparent
                    this.clouds.push(cloud);
                }

                // Grid system parameters
                this.CLOUD_GRID_SIZE = 800; // 800x800 pixel grid cells
                this.cloudGridData = new Map(); // Stores pre-generated cloud positions by grid key
            }

            generateCloudDataForGrid(gridX, gridY) {
                // Generate deterministic cloud positions for a grid cell
                // Each grid cell is CLOUD_GRID_SIZE x CLOUD_GRID_SIZE pixels

                const centerX = gridX * this.CLOUD_GRID_SIZE;
                const centerY = gridY * this.CLOUD_GRID_SIZE;

                // Only generate clouds at 100m altitude and above
                // In the game, higher altitude = lower Y values
                const minCloudY = this.SEA_LEVEL - (100 * this.PIXELS_PER_METER); // Y at 100m altitude
                if (centerY >= this.SEA_LEVEL) {
                    return []; // No clouds at or below sea level
                }

                // Use grid coordinates as seed for deterministic randomness
                const seed = Math.abs((gridX * 73 + gridY * 151) * 12347); // Better seed distribution
                const pseudoRandom = (s) => {
                    const x = Math.sin(s) * 10000;
                    return x - Math.floor(x);
                };

                const clouds = [];

                // 1-2 clouds per grid cell for good density without overkill
                const numClouds = Math.floor(pseudoRandom(seed)) + 1;

                for (let i = 0; i < numClouds; i++) {
                    const cloudSeed = seed + i * 2137; // Better seed spacing

                    // Position within the grid cell with some overlap into adjacent cells
                    const x = centerX + (pseudoRandom(cloudSeed) - 0.5) * this.CLOUD_GRID_SIZE * 1.2;
                    const y = centerY + (pseudoRandom(cloudSeed + 1) - 0.5) * this.CLOUD_GRID_SIZE * 1.2;

                    // Better cloud type selection to ensure both types appear
                    const cloudType = pseudoRandom(cloudSeed + 2) > 0.5 ? 'cloud_1' : 'cloud_2';

                    // Ensure proper scale range 0.2-0.6
                    const scaleRandom = pseudoRandom(cloudSeed + 3);
                    const finalScale = 0.2 + (scaleRandom * 0.4);

                    clouds.push({
                        x: x,
                        y: y,
                        type: cloudType,
                        scale: finalScale
                    });
                }

                return clouds;
            }

            updateClouds() {
                // Only update clouds periodically for performance
                if (this.time.now - this.lastCloudCheck < this.cloudCheckInterval) {
                    return;
                }
                this.lastCloudCheck = this.time.now;

                // Get current camera bounds with buffer
                const camera = this.cameras.main;
                const buffer = 1200; // Buffer for smooth appearance/disappearance
                const viewTop = camera.scrollY - buffer;
                const viewBottom = camera.scrollY + camera.height + buffer;
                const viewLeft = camera.scrollX - buffer;
                const viewRight = camera.scrollX + camera.width + buffer;

                // Hide all clouds first
                this.clouds.forEach(cloud => cloud.setVisible(false));

                // Calculate which grid cells are visible
                const gridLeft = Math.floor(viewLeft / this.CLOUD_GRID_SIZE);
                const gridRight = Math.floor(viewRight / this.CLOUD_GRID_SIZE);
                const gridTop = Math.floor(viewTop / this.CLOUD_GRID_SIZE);
                const gridBottom = Math.floor(viewBottom / this.CLOUD_GRID_SIZE);

                // Collect all visible clouds with distance to camera center
                const cameraX = camera.scrollX + camera.width / 2;
                const cameraY = camera.scrollY + camera.height / 2;
                const visibleClouds = [];

                // Generate and collect clouds for visible grid cells
                for (let gridY = gridTop; gridY <= gridBottom; gridY++) {
                    for (let gridX = gridLeft; gridX <= gridRight; gridX++) {

                        // Create unique key for this grid cell
                        const gridKey = `${gridX},${gridY}`;

                        // Get or generate cloud data for this grid cell
                        if (!this.cloudGridData.has(gridKey)) {
                            this.cloudGridData.set(gridKey, this.generateCloudDataForGrid(gridX, gridY));
                        }

                        const gridCloudData = this.cloudGridData.get(gridKey);

                        for (const cloudData of gridCloudData) {
                            // Check if cloud is within view bounds
                            if (cloudData.x >= viewLeft && cloudData.x <= viewRight &&
                                cloudData.y >= viewTop && cloudData.y <= viewBottom) {

                                // Calculate distance to camera center for prioritization
                                const distance = Math.sqrt(
                                    Math.pow(cloudData.x - cameraX, 2) +
                                    Math.pow(cloudData.y - cameraY, 2)
                                );

                                visibleClouds.push({
                                    ...cloudData,
                                    distance: distance
                                });
                            }
                        }
                    }
                }

                // Sort clouds by distance and take only the closest ones that fit in our pool
                visibleClouds.sort((a, b) => a.distance - b.distance);
                const cloudsToShow = visibleClouds.slice(0, this.clouds.length);

                // Show the prioritized clouds
                cloudsToShow.forEach((cloudData, index) => {
                    const cloud = this.clouds[index];
                    cloud.setTexture(cloudData.type);
                    cloud.setPosition(cloudData.x, cloudData.y);
                    cloud.setScale(cloudData.scale);
                    cloud.setVisible(true);
                });

                // Clean up old cloud data to prevent memory buildup
                if (this.cloudGridData.size > 100) {
                    const currentGridX = Math.floor(this.ship.x / this.CLOUD_GRID_SIZE);
                    const currentGridY = Math.floor(this.ship.y / this.CLOUD_GRID_SIZE);

                    for (const [gridKey] of this.cloudGridData) {
                        const [x, y] = gridKey.split(',').map(Number);
                        const distance = Math.abs(x - currentGridX) + Math.abs(y - currentGridY);
                        if (distance > 20) { // Keep grid cells within 20 cells of player
                            this.cloudGridData.delete(gridKey);
                        }
                    }
                }
            }

            hasCannonballInRightmostSlot() {
                return this.cannonballSlots[3]; // Rightmost slot is index 3
            }

            showHelpPopup() {
                if (this.gameState !== 'playing') return;

                console.log('Showing help popup - pausing all game logic');

                // Set help state and pause physics
                this.gameState = 'help';

                // Pause physics world to stop all movement
                this.physics.world.pause();

                // Store and pause all tweens
                this.tweens.pauseAll();

                // Create help popup background - 2:3 ratio
                this.helpPopupBG = this.add.rectangle(450, 800, 720, 1180, 0x2c3e50);
                this.helpPopupBG.setScrollFactor(0);
                this.helpPopupBG.setDepth(2000);
                this.helpPopupBG.setStrokeStyle(4, 0xffffff);
                this.helpPopupBG.setInteractive();

                // Create help title - bigger and better positioned
                this.helpTitle = this.add.text(450, 350, 'HOW TO PLAY', {
                    fontSize: '56px',
                    fill: '#ffffff',
                    fontWeight: 'bold',
                    align: 'center'
                }).setOrigin(0.5);
                this.helpTitle.setScrollFactor(0);
                this.helpTitle.setDepth(2001);

                // Create help text - left aligned and vertically centered
                const helpText = `• tap to shoot in that direction

• firing your cannon propels you
  in the opposite direction

• collect flying cannonballs
  for more ammo

• go as high as possible!

• do NOT press the selfdestruct button`;

                this.helpContent = this.add.text(450, 700, helpText, {
                    fontSize: '28px',
                    fill: '#ecf0f1',
                    align: 'left',
                    lineSpacing: 8,
                    wordWrap: { width: 620 }
                }).setOrigin(0.5);
                this.helpContent.setScrollFactor(0);
                this.helpContent.setDepth(2001);

                // Create self-destruct button - better positioned
                this.destructButton = this.add.image(450, 1050, 'button_destruct');
                this.destructButton.setDisplaySize(this.CANNONBALL_SIZE * 1.9, this.CANNONBALL_SIZE * 1.9);
                this.destructButton.setScrollFactor(0);
                this.destructButton.setDepth(2002); // Higher depth to ensure it's on top
                this.destructButton.setInteractive();
                this.destructButton.on('pointerdown', (pointer, localX, localY, event) => {
                    console.log('Self-destruct activated!');
                    event.stopPropagation(); // Prevent background click
                    this.hideHelpPopup();
                    this.gameOver();
                });

                // Store help popup elements
                this.helpPopupElements = [
                    this.helpPopupBG,
                    this.helpTitle,
                    this.helpContent,
                    this.destructButton
                ];

                // Click background to close
                this.helpPopupBG.on('pointerdown', () => {
                    console.log('Clicked inside popup - closing help');
                    this.hideHelpPopup();
                });

                // Add outside click handler with a delay to avoid immediate closure
                this.time.delayedCall(100, () => {
                    this.helpOutsideClickHandler = (pointer) => {
                        // Calculate popup bounds
                        const popupLeft = 450 - 360; // 450 - (720/2)
                        const popupRight = 450 + 360; // 450 + (720/2)
                        const popupTop = 800 - 590; // 800 - (1180/2)
                        const popupBottom = 800 + 590; // 800 + (1180/2)

                        // Check if click is outside popup bounds
                        if (pointer.x < popupLeft || pointer.x > popupRight ||
                            pointer.y < popupTop || pointer.y > popupBottom) {
                            console.log('Clicked outside popup - closing help');
                            this.hideHelpPopup();
                        }
                    };

                    this.input.on('pointerdown', this.helpOutsideClickHandler);
                });
            }

            hideHelpPopup() {
                console.log('Hiding help popup - resuming all game logic');

                // Remove outside click handler
                if (this.helpOutsideClickHandler) {
                    this.input.off('pointerdown', this.helpOutsideClickHandler);
                    this.helpOutsideClickHandler = null;
                }

                // Destroy popup elements
                if (this.helpPopupElements) {
                    this.helpPopupElements.forEach(element => {
                        if (element && element.destroy) {
                            element.destroy();
                        }
                    });
                    this.helpPopupElements = null;
                }

                // Resume physics and tweens
                this.physics.world.resume();
                this.tweens.resumeAll();

                // Resume the game
                this.gameState = 'playing';
            }

            getTotalCannonballs() {
                return this.cannonballSlots.filter(slot => slot).length;
            }

            showTitleScreen() {
                this.gameElements.forEach(element => element.setVisible(false));
                this.uiElements.forEach(element => element.setVisible(false));
                this.clouds.forEach(cloud => cloud.setVisible(false));
                this.titleElements.forEach(element => element.setVisible(true));
                this.gameState = 'menu';
            }

            showGameScreen() {
                this.titleElements.forEach(element => element.setVisible(false));
                this.gameElements.forEach(element => element.setVisible(true));
                this.uiElements.forEach(element => element.setVisible(true));
                this.gameState = 'playing';
            }

            startGame() {
                console.log('Starting game...');
                this.showGameScreen();

                // Reset game state
                this.cannonballSlots = [true, true, true, true]; // All slots start filled
                this.maxHeight = 0;
                this.currentHeight = 0;
                this.flyingBallSpawnRate = 300;
                this.flyingBallTimer = 0;
                this.cameraFollowing = false;
                this.gameStartTime = this.time.now;
                this.initialSpawnCounter = 0;
                this.highestAltitudeZone = 0;
                this.cannonCharging = false;
                this.dormantCannonballs = [];
                this.isRollingCannonballs = false;

                // Reset cloud system
                this.cloudGridData.clear();
                this.lastCloudCheck = 0;

                // Reset cooldown state
                this.cannonOnCooldown = false;
                this.cannonCooldownStart = 0;

                // Reset ship position and physics
                this.ship.setPosition(450, this.SEA_LEVEL - this.SHIP_SIZE / 2);
                this.ship.setVelocity(0, 0);
                this.ship.body.setAllowGravity(false);
                this.ship.body.setImmovable(false);

                // Reset cannon position and angle
                this.cannon.x = this.ship.x;
                this.cannon.y = this.ship.y + 80;
                this.cannonAngle = Math.PI / 2;
                this.cannon.setRotation(this.cannonAngle);

                // Clear projectiles
                this.flyingBalls.clear(true, true);
                this.cannonballProjectiles.clear(true, true);

                // Camera follows ship with instant following (no lag)
                this.cameras.main.setZoom(1);
                this.cameras.main.startFollow(this.ship, true, 1, 0);
                this.cameras.main.scrollY = this.SEA_LEVEL - 800;

                console.log('Using instant camera following (lerp=1) to eliminate interpolation lag');

                // Spawn initial cannonballs
                this.spawnInitialCannonballs();

                // Update UI
                this.updateCannonballUI();
                this.updateHeightDisplay();

                console.log('Game started - Ship floating at sea level:', this.ship.x, this.ship.y);
            }

            updateCannonAngle() {
                if (this.gameState !== 'playing') return;

                const cannonX = this.cannon.x;
                const cannonY = this.cannon.y;

                // Convert screen coordinates to world coordinates
                const camera = this.cameras.main;
                const worldPointerX = this.lastPointerPosition.x + camera.scrollX;
                const worldPointerY = this.lastPointerPosition.y + camera.scrollY;

                this.cannonAngle = Phaser.Math.Angle.Between(cannonX, cannonY, worldPointerX, worldPointerY);

                // Limit cannon to 180° downward arc
                if (this.cannonAngle < 0) {
                    this.cannonAngle = 0;
                }
                if (this.cannonAngle > Math.PI) {
                    this.cannonAngle = Math.PI;
                }

                this.cannon.setRotation(this.cannonAngle + Math.PI / 2); // Fixed rotation
            }

            startCannonCharge() {
                if (!this.hasCannonballInRightmostSlot() || this.cannonOnCooldown || this.cannonCharging || this.isRollingCannonballs) {
                    return;
                }

                console.log(`Starting cannon charge... Will fire in ${this.CANNON_CHARGE_TIME}ms`);
                this.cannonCharging = true;
                this.cannonChargeStart = this.time.now;

                this.chargeTimer = this.time.delayedCall(this.CANNON_CHARGE_TIME, () => {
                    if (this.cannonCharging && this.gameState === 'playing') {
                        this.fireCannon();
                    }
                });
            }

            fireCannon() {
                if (!this.hasCannonballInRightmostSlot()) {
                    return;
                }

                console.log(`BOOM! Firing cannon with power ${this.CANNON_POWER}`);
                console.log(`Before firing, slots:`, [...this.cannonballSlots]);

                // Reset charging state
                this.cannonCharging = false;
                if (this.chargeTimer) {
                    this.chargeTimer.destroy();
                    this.chargeTimer = null;
                }

                // Start cooldown
                this.cannonOnCooldown = true;
                this.cannonCooldownStart = this.time.now;
                this.isRollingCannonballs = true;

                // Reset cannon visual
                this.cannon.setTint(0xffffff);

                // STEP 1: Calculate which balls will move and store their current visual positions
                const ballMovements = [];
                for (let i = 0; i < 3; i++) { // Check slots 0,1,2
                    if (this.cannonballSlots[i]) {
                        // This ball will move from slot i to slot i+1
                        const currentX = this.cannonballUI[i].x;
                        const targetX = this.cannonballSlotPositions[i + 1];
                        ballMovements.push({
                            fromSlot: i,
                            toSlot: i + 1,
                            currentX: currentX,
                            targetX: targetX
                        });
                    }
                }

                console.log(`Ball movements:`, ballMovements);

                // STEP 2: Update logical state immediately - roll balls right, clear rightmost
                const newSlots = [false, false, false, false];
                for (let i = 0; i < 3; i++) {
                    if (this.cannonballSlots[i]) {
                        newSlots[i + 1] = true;
                    }
                }
                this.cannonballSlots = newSlots;

                console.log(`After firing, slots:`, newSlots);

                // STEP 3: Update UI immediately to correct logical state
                // This will show slot 3 as gray immediately since newSlots[3] = false
                this.updateCannonballUI();

                // STEP 4: Now animate the visual rolling on top of the correct final state
                ballMovements.forEach(movement => {
                    const { fromSlot, toSlot, currentX, targetX } = movement;
                    const ball = this.cannonballUI[toSlot]; // Ball is now logically at toSlot

                    // Temporarily put it back at the old position for animation
                    ball.x = currentX;

                    console.log(`Animating ball from slot ${fromSlot} to ${toSlot}, x: ${currentX} -> ${targetX}`);

                    // Animate to new position
                    this.tweens.add({
                        targets: ball,
                        x: targetX,
                        duration: this.CANNON_COOLDOWN_TIME,
                        ease: 'Power2.easeOut'
                    });

                    // Add rotation
                    this.tweens.add({
                        targets: ball,
                        rotation: ball.rotation + Math.PI * 4,
                        duration: this.CANNON_COOLDOWN_TIME,
                        ease: 'Power2.easeOut'
                    });
                });

                // Enable gravity on first shot
                if (!this.ship.body.allowGravity) {
                    this.ship.body.setAllowGravity(true);
                    this.ship.body.setGravityY(this.GRAVITY);
                    console.log('Gravity enabled for ship');
                }

                // Create visual projectile at cannon position
                const projectile = this.add.image(this.cannon.x, this.cannon.y, 'cannonball');
                projectile.setDisplaySize(80, 80);

                this.physics.add.existing(projectile);
                this.cannonballProjectiles.add(projectile);

                // Fire projectile in cannon direction
                const projectileSpeed = 1600;
                const projectileVelX = Math.cos(this.cannonAngle) * projectileSpeed;
                const projectileVelY = Math.sin(this.cannonAngle) * projectileSpeed;
                projectile.body.setVelocity(projectileVelX, projectileVelY);
                projectile.body.setGravityY(this.GRAVITY * 0.5);

                // Launch ship in opposite direction
                const velocityX = -Math.cos(this.cannonAngle) * this.CANNON_POWER;
                const velocityY = -Math.sin(this.cannonAngle) * this.CANNON_POWER;

                this.ship.setVelocity(velocityX, velocityY);

                // End rolling when animation completes
                this.time.delayedCall(this.CANNON_COOLDOWN_TIME, () => {
                    this.isRollingCannonballs = false;
                    this.updateCannonballUI(); // Final cleanup
                });

                console.log(`FIRED! Ship velocity: X=${velocityX.toFixed(0)}, Y=${velocityY.toFixed(0)}`);
            }



            spawnInitialCannonballs() {
                for (let i = 0; i < 15; i++) {
                    const x = this.ship.x + Phaser.Math.Between(-1000, 1000);
                    const y = this.ship.y - Phaser.Math.Between(50, 500);
                    this.createFlyingBall(x, y);
                }
                console.log('Spawned 15 initial cannonballs with wide spread');
            }

            checkAltitudeSpawning() {
                const currentAltitude = this.currentHeight;
                const currentZone = Math.floor(currentAltitude / 50);

                if (currentZone > this.highestAltitudeZone) {
                    console.log(`Reached ${currentZone * 50}m altitude - spawning cannonballs at ${(currentZone + 1) * 50}m`);

                    const spawnAltitude = (currentZone + 1) * 50;
                    const spawnY = this.SEA_LEVEL - (spawnAltitude * this.PIXELS_PER_METER);

                    const baseCannonballs = 8;
                    const altitudeReduction = Math.floor(currentZone / 4);
                    const cannonballCount = Math.max(2, baseCannonballs - altitudeReduction);

                    console.log(`Spawning ${cannonballCount} cannonballs`);

                    for (let i = 0; i < cannonballCount; i++) {
                        const spawnX = this.ship.x + Phaser.Math.Between(-1000, 1000);
                        const spawnYVaried = spawnY + Phaser.Math.Between(-1000, -50);
                        this.createFlyingBall(spawnX, spawnYVaried);
                    }

                    this.highestAltitudeZone = currentZone;
                }
            }

            checkDormantCannonballs() {
                this.dormantCannonballs = this.dormantCannonballs.filter((dormant, index) => {
                    const distance = Phaser.Math.Distance.Between(dormant.x, dormant.y, this.ship.x, this.ship.y);
                    if (distance < this.RESPAWN_DISTANCE) {
                        this.createFlyingBall(dormant.x, dormant.y);
                        console.log(`Respawned dormant cannonball at altitude ${dormant.altitude}m`);
                        return false;
                    }
                    return true;
                });
            }

            createFlyingBall(x, y) {
                const flyingBall = this.add.image(x, y, 'cannonball');
                flyingBall.setDisplaySize(this.FLYING_BALL_SIZE, this.FLYING_BALL_SIZE);

                this.physics.add.existing(flyingBall);
                this.flyingBalls.add(flyingBall);

                // Create wings with proper pivot setup
                const leftWing = this.add.image(x, y, 'wing');
                leftWing.setDisplaySize(80, 40);
                leftWing.setFlipX(true);
                leftWing.setOrigin(0.9, 0.6); // Right edge as pivot point

                const rightWing = this.add.image(x, y, 'wing');
                rightWing.setDisplaySize(80, 40);
                rightWing.setOrigin(0.1, 0.6); // Left edge as pivot point

                // Generate randomized flapping parameters for variation
                const leftWingUpAngle = Phaser.Math.DegToRad(Phaser.Math.Between(30, 60));
                const leftWingDownAngle = Phaser.Math.DegToRad(Phaser.Math.Between(-60, -30));
                const rightWingUpAngle = Phaser.Math.DegToRad(Phaser.Math.Between(-60, -30));
                const rightWingDownAngle = Phaser.Math.DegToRad(Phaser.Math.Between(30, 60));

                const flapDuration = Phaser.Math.Between(300, 500);
                const phaseOffset = Phaser.Math.Between(0, flapDuration);

                // Create rotation-based wing animation
                this.tweens.add({
                    targets: leftWing,
                    rotation: leftWingDownAngle,
                    duration: flapDuration,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut',
                    delay: phaseOffset
                });

                this.tweens.add({
                    targets: rightWing,
                    rotation: rightWingDownAngle,
                    duration: flapDuration,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut',
                    delay: phaseOffset
                });

                // Set initial wing angles
                leftWing.setRotation(leftWingUpAngle);
                rightWing.setRotation(rightWingUpAngle);

                flyingBall.leftWing = leftWing;
                flyingBall.rightWing = rightWing;

                flyingBall.body.setVelocity(
                    Phaser.Math.Between(-80, 80),
                    Phaser.Math.Between(-40, 40)
                );
            }

            collectFlyingBall(ship, flyingBall) {
                const currentCount = this.getTotalCannonballs();

                if (currentCount < 4) {
                    // Add one more cannonball and redistribute ALL balls to rightmost positions
                    const newCount = currentCount + 1;

                    console.log(`Collecting ball. Current count: ${currentCount}, new count: ${newCount}`);
                    console.log(`Before collection, slots:`, [...this.cannonballSlots]);

                    // Clear all slots and fill from the right
                    const newSlots = [false, false, false, false];
                    for (let i = 0; i < newCount; i++) {
                        newSlots[3 - i] = true; // Fill rightmost slots first: 3, 2, 1, 0
                    }

                    // The newly collected ball will be at the leftmost of the filled slots
                    const newBallSlot = 4 - newCount; // 3 for 1 ball, 2 for 2 balls, 1 for 3 balls, 0 for 4 balls

                    this.cannonballSlots = newSlots;
                    this.updateCannonballUI();

                    // Apply gold tint to the newly collected ball and animate to normal white
                    const newBall = this.cannonballUI[newBallSlot];
                    newBall.setTint(0xFFD700); // Gold tint (same as cooldown circle)

                    // Animate back to normal white over cooldown time
                    this.tweens.add({
                        targets: newBall,
                        tint: 0xffffff, // Back to normal white
                        duration: this.CANNON_COOLDOWN_TIME,
                        ease: 'Power2.easeOut'
                    });

                    console.log(`After collection, slots:`, newSlots, `New ball in slot ${newBallSlot} with light tint`);

                    if (flyingBall.leftWing) flyingBall.leftWing.destroy();
                    if (flyingBall.rightWing) flyingBall.rightWing.destroy();
                    flyingBall.destroy();

                    console.log(`Collected ball! New total: ${newCount}, all balls settled rightward`);
                }
            }

            updateCannonballUI() {
                // Gray placeholders are always visible, just update the actual cannonballs
                for (let i = 0; i < 4; i++) {
                    const ball = this.cannonballUI[i];

                    // Ensure ball is at correct position (unless currently animating)
                    if (!this.isRollingCannonballs) {
                        ball.x = this.cannonballSlotPositions[i];
                        ball.rotation = 0; // Reset rotation when not rolling
                    }

                    // Show/hide actual cannonball based on slot state
                    if (this.cannonballSlots[i]) {
                        // Slot has a cannonball - show white cannonball on top of gray placeholder
                        ball.setVisible(true);
                        ball.setTint(0xffffff);
                        ball.setAlpha(1.0);
                    } else {
                        // Slot is empty - hide the white cannonball, gray placeholder shows through
                        ball.setVisible(false);
                    }
                }

                this.updateCooldownCircles();
            }

            updateCooldownCircles() {
                const canFire = !this.cannonCharging && !this.cannonOnCooldown && !this.isRollingCannonballs && this.hasCannonballInRightmostSlot();

                // Only show cooldown circle on rightmost slot (index 3)
                for (let i = 0; i < 4; i++) {
                    const cooldownGraphic = this.cooldownGraphics[i];
                    cooldownGraphic.clear();

                    // Only show circle on rightmost slot that has a cannonball
                    if (i === 3 && this.cannonballSlots[i]) {
                        const x = this.cannonballSlotPositions[i];
                        const y = 1500;
                        const radius = this.CANNONBALL_SIZE + 4;

                        if (canFire) {
                            // Full golden circle when ready to fire
                            cooldownGraphic.lineStyle(4, 0xFFD700);
                            cooldownGraphic.strokeCircle(x, y, radius);
                        } else if (this.cannonOnCooldown) {
                            // Show cooldown progress
                            const elapsed = this.time.now - this.cannonCooldownStart;
                            const progress = Math.min(elapsed / this.CANNON_COOLDOWN_TIME, 1);

                            if (progress < 1) {
                                const startAngle = -Math.PI / 2;
                                const endAngle = startAngle + (progress * Math.PI * 2);

                                cooldownGraphic.lineStyle(4, 0xFFD700);
                                cooldownGraphic.beginPath();
                                cooldownGraphic.arc(x, y, radius, startAngle, endAngle);
                                cooldownGraphic.strokePath();
                            } else {
                                cooldownGraphic.lineStyle(4, 0xFFD700);
                                cooldownGraphic.strokeCircle(x, y, radius);
                            }
                        }
                    }
                }
            }

            updateHeightDisplay() {
                const shipFloatingPosition = this.SEA_LEVEL - this.SHIP_SIZE / 2;
                const heightAboveSeaInPixels = shipFloatingPosition - this.ship.y;
                const heightInMeters = Math.max(0, Math.floor(heightAboveSeaInPixels / this.PIXELS_PER_METER));

                this.currentHeight = heightInMeters;
                this.maxHeight = Math.max(this.maxHeight, heightInMeters);
                this.heightText.setText(`Height: ${heightInMeters}m`);
            }

            updateCamera() {
                if (this.gameState !== 'playing') return;

                const shipFloatingPosition = this.SEA_LEVEL - this.SHIP_SIZE / 2;
                const shipHeightAboveSeaLevel = shipFloatingPosition - this.ship.y;

                // Switch camera following mode based on height
                if (shipHeightAboveSeaLevel > 200 && !this.cameraFollowing) {
                    this.cameraFollowing = true;
                    console.log('Camera now following ship vertically');
                    // Switch to following both axes instantly
                    this.cameras.main.setLerp(1, 1);

                } else if (shipHeightAboveSeaLevel < 100 && this.cameraFollowing) {
                    this.cameraFollowing = false;
                    console.log('Camera stopped following ship vertically');
                    // Follow horizontally but not vertically
                    this.cameras.main.setLerp(1, 0);
                    // Only set Y position once when transitioning, not every frame
                    this.cameras.main.scrollY = this.SEA_LEVEL - 800;
                }

                // Don't constantly override scrollY - let camera system handle it
            }

            checkGameOver() {
                if (!this.gameStartTime || (this.time.now - this.gameStartTime < 1000)) {
                    return;
                }

                const shipFloatingPosition = this.SEA_LEVEL - this.SHIP_SIZE / 2;
                const shipAtSeaLevel = this.ship.y >= shipFloatingPosition;

                if (shipAtSeaLevel) {
                    if (this.getTotalCannonballs() <= 0 && this.ship.body.velocity.y >= -50) {
                        if (!this.gameOverTimer) {
                            this.gameOverTimer = this.time.now;
                        } else if (this.time.now - this.gameOverTimer > 1500) {
                            this.gameOver();
                        }
                    } else {
                        this.gameOverTimer = null;
                    }

                    if (this.ship.body.velocity.y > 500) {
                        this.gameOver();
                    }
                } else {
                    this.gameOverTimer = null;
                }
            }

            gameOver() {
                if (this.gameState === 'gameOver') return;

                this.gameState = 'gameOver';
                console.log(`Game Over! Max height: ${this.maxHeight}m`);

                if (this.maxHeight > this.personalBest) {
                    this.personalBest = this.maxHeight;
                    localStorage.setItem('verticalLauncherBest', this.personalBest.toString());
                    this.personalBestText.setText(`Best: ${this.personalBest}m`);
                }

                this.ship.setVelocity(0, 0);
                this.ship.body.setAllowGravity(false);

                // Reset camera following state but don't stop following yet
                this.cameraFollowing = false;

                this.time.delayedCall(2000, () => {
                    this.showGameOverScreen();
                });
            }

            showGameOverScreen() {
                // Stop following and return camera to initial position
                this.cameras.main.stopFollow();
                this.cameras.main.setScroll(0, this.SEA_LEVEL - 800);

                this.showTitleScreen();

                this.titleText.setText('GAME OVER');
                this.playButtonText.setText('PLAY AGAIN');

                const scoreText = this.add.text(450, 650, `Max Height: ${this.maxHeight}m`, {
                    fontSize: '48px',
                    fill: '#e74c3c',
                    fontWeight: 'bold'
                }).setOrigin(0.5);
                scoreText.setScrollFactor(0);
                scoreText.setDepth(2001);

                this.playButton.removeAllListeners();
                this.playButton.on('pointerdown', () => {
                    scoreText.destroy();
                    this.titleText.setText('VERTICAL\nLAUNCHER');
                    this.playButtonText.setText('PLAY GAME');
                    this.restartGame();
                });
            }

            restartGame() {
                console.log('Restarting game - resetting all states');

                this.gameOverTimer = null;
                this.initialSpawnCounter = 0;
                this.highestAltitudeZone = 0;
                this.cannonCharging = false;
                this.cannonShakeOffset = { x: 0, y: 0 };
                this.dormantCannonballs = [];
                this.isRollingCannonballs = false;

                this.cannonOnCooldown = false;
                this.cannonCooldownStart = 0;

                if (this.chargeTimer) {
                    this.chargeTimer.destroy();
                    this.chargeTimer = null;
                }

                // Reset camera following state
                this.cameraFollowing = false;

                this.ship.body.setAllowGravity(false);
                this.ship.body.setGravityY(0);
                this.ship.body.setImmovable(false);
                this.ship.setVelocity(0, 0);

                this.flyingBalls.children.entries.forEach(ball => {
                    if (ball.leftWing) ball.leftWing.destroy();
                    if (ball.rightWing) ball.rightWing.destroy();
                });
                this.flyingBalls.clear(true, true);
                this.cannonballProjectiles.clear(true, true);

                this.startGame();
            }

            update(time, delta) {
                if (this.gameState !== 'playing') return;

                // Keep ship floating at sea level if gravity not enabled yet
                if (!this.ship.body.allowGravity) {
                    this.ship.setPosition(this.ship.x, this.SEA_LEVEL - this.SHIP_SIZE / 2);
                    this.ship.setVelocity(0, 0);
                }

                // Update cooldown state
                if (this.cannonOnCooldown) {
                    const elapsed = this.time.now - this.cannonCooldownStart;
                    if (elapsed >= this.CANNON_COOLDOWN_TIME) {
                        this.cannonOnCooldown = false;
                        console.log('Cannon cooldown completed - ready to fire');
                    }
                }

                // Position cannon based on ship's physics body position for perfect sync
                const shipCenterX = this.ship.body.x + this.ship.body.width / 2;
                const shipCenterY = this.ship.body.y + this.ship.body.height / 2;

                // Calculate ship speed for visual effects
                const shipSpeed = Math.sqrt(this.ship.body.velocity.x * this.ship.body.velocity.x + this.ship.body.velocity.y * this.ship.body.velocity.y);
                const maxSpeed = 3000; // Approximate max speed after cannon shot
                const speedRatio = Math.min(shipSpeed / maxSpeed, 1); // 0 to 1

                // Apply subtle speed-based rotation oscillation to ship
                if (speedRatio > 0.1) { // Only apply when moving at decent speed
                    const oscillationTime = this.time.now * 0.01; // Oscillation frequency
                    const maxRotation = Phaser.Math.DegToRad(10); // Max 10 degrees as requested
                    const rotationAmount = Math.sin(oscillationTime) * maxRotation * speedRatio;
                    this.ship.setRotation(rotationAmount);
                } else {
                    this.ship.setRotation(0); // No rotation when moving slowly
                }

                // Handle cannon charging and shaking
                if (this.cannonCharging) {
                    const chargeProgress = (this.time.now - this.cannonChargeStart) / this.CANNON_CHARGE_TIME;
                    const shakeIntensity = Math.min(chargeProgress * 20, 20);

                    this.cannon.x = shipCenterX + (Math.random() - 0.5) * shakeIntensity;
                    this.cannon.y = shipCenterY + 80 + (Math.random() - 0.5) * shakeIntensity;

                    this.cannon.setTint(0xff4444); // Red during charge
                } else {
                    // Add subtle speed-based positional shake to cannon
                    const shakeAmount = speedRatio * 3; // Very subtle positional shake
                    const shakeX = (Math.random() - 0.5) * shakeAmount;
                    const shakeY = (Math.random() - 0.5) * shakeAmount;

                    this.cannon.x = shipCenterX + shakeX;
                    this.cannon.y = shipCenterY + 80 + shakeY;
                    this.cannon.setTint(0xffffff); // Normal color
                }

                // Update cannon angle
                this.updateCannonAngle();

                // Update wing positions to follow their cannonballs
                this.flyingBalls.children.entries.forEach(ball => {
                    if (ball.leftWing) {
                        ball.leftWing.x = ball.x - 30;
                        ball.leftWing.y = ball.y;
                    }
                    if (ball.rightWing) {
                        ball.rightWing.x = ball.x + 30;
                        ball.rightWing.y = ball.y;
                    }
                });

                // Handle space key
                if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) {
                    const canFire = this.gameState === 'playing' &&
                        this.gameStartTime &&
                        (this.time.now - this.gameStartTime > 500) &&
                        !this.cannonCharging &&
                        !this.cannonOnCooldown &&
                        !this.isRollingCannonballs &&
                        this.hasCannonballInRightmostSlot();

                    if (canFire) {
                        this.startCannonCharge();
                    }
                }

                // Update game state
                this.updateHeightDisplay();
                this.updateCamera();
                this.updateCooldownCircles();

                // Update cloud system
                this.updateClouds();

                // Check for altitude-based spawning
                this.checkAltitudeSpawning();

                // Check for dormant cannonball respawning
                this.checkDormantCannonballs();

                // Clean up projectiles
                this.cannonballProjectiles.children.entries.forEach(projectile => {
                    const distance = Phaser.Math.Distance.Between(projectile.x, projectile.y, this.ship.x, this.ship.y);
                    if (distance > 5000) {
                        projectile.destroy();
                    }
                });

                // Clean up flying balls
                this.flyingBalls.children.entries.forEach(ball => {
                    const distance = Phaser.Math.Distance.Between(ball.x, ball.y, this.ship.x, this.ship.y);
                    if (distance > 3000) {
                        const altitude = Math.floor((this.SEA_LEVEL - ball.y) / this.PIXELS_PER_METER);
                        this.dormantCannonballs.push({
                            x: ball.x,
                            y: ball.y,
                            altitude: altitude
                        });

                        console.log(`Stored dormant cannonball at altitude ${altitude}m (total dormant: ${this.dormantCannonballs.length})`);

                        if (ball.leftWing) ball.leftWing.destroy();
                        if (ball.rightWing) ball.rightWing.destroy();
                        ball.destroy();
                    }
                });

                // Only check game over after gravity is enabled
                if (this.ship.body.allowGravity) {
                    this.checkGameOver();
                }
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 900,
            height: 1600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: VerticalLauncher,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>